 _ `	 (*  IDENTIFIER BACK_TICK *)
	 (*  *)
 * )	 (*  TIMES RPAREN *)
	 (*  *)
	 (*  *)
 t = - 2.3E4	 (*  IDENTIFIER EQ MINUS B10_NUMBER *)
 t = 2E-3	 (*  IDENTIFIER EQ B10_NUMBER *)
 t = 2.0	 (*  IDENTIFIER EQ B10_NUMBER *)
 t = 23 - 44	 (*  IDENTIFIER EQ B10_NUMBER MINUS B10_NUMBER *)
 t = 1E4	 (*  IDENTIFIER EQ B10_NUMBER *)
 abc := &01234	 (*  IDENTIFIER ASSIGNMENT OCTAL_NUMBER *)
 abc := $ffFF124	 (*  IDENTIFIER ASSIGNMENT HEXADECIMAL_NUMBER *)
 abc := %01001001	 (*  IDENTIFIER ASSIGNMENT BIN_NUMBER *)
 'This is a pascal string'	 (*  STRING *)
 ''	 (*  STRING *)
Illegal character '"'
Illegal character '"'
 'a'	 (*  STRING *)
 'A tabulator character: ’#9’ is easy to embed'	 (*  STRING *)
 #$ffFF124	 (*  STRING *)
 begin	 (*  RESERVED_BEGIN *)
 while ( t > 0 ) do	 (*  RESERVED_WHILE LPAREN IDENTIFIER GT B10_NUMBER RPAREN RESERVED_DO *)
 begin	 (*  RESERVED_BEGIN *)
 for i := 1 to n do	 (*  RESERVED_FOR IDENTIFIER ASSIGNMENT B10_NUMBER RESERVED_TO IDENTIFIER RESERVED_DO *)
 begin	 (*  RESERVED_BEGIN *)
 read ( a [ i ] ) ;	 (*  MODIFIER_READ LPAREN IDENTIFIER L_SQUARE_BRACKET IDENTIFIER R_SQUARE_BRACKET RPAREN SEMI_COLON *)
	 (*  *)
 b [ i ] := 0 ;	 (*  IDENTIFIER L_SQUARE_BRACKET IDENTIFIER R_SQUARE_BRACKET ASSIGNMENT B10_NUMBER SEMI_COLON *)
 c [ i ] := 0 ;	 (*  IDENTIFIER L_SQUARE_BRACKET IDENTIFIER R_SQUARE_BRACKET ASSIGNMENT B10_NUMBER SEMI_COLON *)
 end ;	 (*  RESERVED_END SEMI_COLON *)
	 (*  *)
 b [ 1 ] := a [ 1 ] ;	 (*  IDENTIFIER L_SQUARE_BRACKET B10_NUMBER R_SQUARE_BRACKET ASSIGNMENT IDENTIFIER L_SQUARE_BRACKET B10_NUMBER R_SQUARE_BRACKET SEMI_COLON *)
 c [ n ] := a [ n ] ;	 (*  IDENTIFIER L_SQUARE_BRACKET IDENTIFIER R_SQUARE_BRACKET ASSIGNMENT IDENTIFIER L_SQUARE_BRACKET IDENTIFIER R_SQUARE_BRACKET SEMI_COLON *)
	 (*  *)
 g := a [ 1 ] ;	 (*  IDENTIFIER ASSIGNMENT IDENTIFIER L_SQUARE_BRACKET B10_NUMBER R_SQUARE_BRACKET SEMI_COLON *)
	 (*  *)
 for i := 2 to n do	 (*  RESERVED_FOR IDENTIFIER ASSIGNMENT B10_NUMBER RESERVED_TO IDENTIFIER RESERVED_DO *)
 begin	 (*  RESERVED_BEGIN *)
 g := gcd_recursive ( g , a [ i ] ) ;	 (*  IDENTIFIER ASSIGNMENT IDENTIFIER LPAREN IDENTIFIER COMMA IDENTIFIER L_SQUARE_BRACKET IDENTIFIER R_SQUARE_BRACKET RPAREN SEMI_COLON *)
 b [ i ] := g ;	 (*  IDENTIFIER L_SQUARE_BRACKET IDENTIFIER R_SQUARE_BRACKET ASSIGNMENT IDENTIFIER SEMI_COLON *)
 end ;	 (*  RESERVED_END SEMI_COLON *)
	 (*  *)
 g := a [ n ] ;	 (*  IDENTIFIER ASSIGNMENT IDENTIFIER L_SQUARE_BRACKET IDENTIFIER R_SQUARE_BRACKET SEMI_COLON *)
	 (*  *)
 for i := n - 1 downto 1 do	 (*  RESERVED_FOR IDENTIFIER ASSIGNMENT IDENTIFIER MINUS B10_NUMBER RESERVED_DOWNTO B10_NUMBER RESERVED_DO *)
 begin	 (*  RESERVED_BEGIN *)
 g := gcd_recursive ( g , a [ i ] ) ;	 (*  IDENTIFIER ASSIGNMENT IDENTIFIER LPAREN IDENTIFIER COMMA IDENTIFIER L_SQUARE_BRACKET IDENTIFIER R_SQUARE_BRACKET RPAREN SEMI_COLON *)
 c [ i ] := g ;	 (*  IDENTIFIER L_SQUARE_BRACKET IDENTIFIER R_SQUARE_BRACKET ASSIGNMENT IDENTIFIER SEMI_COLON *)
 end ;	 (*  RESERVED_END SEMI_COLON *)
	 (*  *)
 while ( q > 0 ) do	 (*  RESERVED_WHILE LPAREN IDENTIFIER GT B10_NUMBER RPAREN RESERVED_DO *)
 begin	 (*  RESERVED_BEGIN *)
 readln ( l , r ) ;	 (*  IDENTIFIER LPAREN IDENTIFIER COMMA IDENTIFIER RPAREN SEMI_COLON *)
	 (*  *)
 if l <> 1 then	 (*  RESERVED_IF IDENTIFIER NE B10_NUMBER RESERVED_THEN *)
 begin	 (*  RESERVED_BEGIN *)
 if r <> n then	 (*  RESERVED_IF IDENTIFIER NE IDENTIFIER RESERVED_THEN *)
 writeln ( gcd_recursive ( b [ l - 1 ] , c [ r + 1 ] ) )	 (*  IDENTIFIER LPAREN IDENTIFIER LPAREN IDENTIFIER L_SQUARE_BRACKET IDENTIFIER MINUS B10_NUMBER R_SQUARE_BRACKET COMMA IDENTIFIER L_SQUARE_BRACKET IDENTIFIER PLUS B10_NUMBER R_SQUARE_BRACKET RPAREN RPAREN *)
 else	 (*  RESERVED_ELSE *)
 writeln ( b [ l - 1 ] )	 (*  IDENTIFIER LPAREN IDENTIFIER L_SQUARE_BRACKET IDENTIFIER MINUS B10_NUMBER R_SQUARE_BRACKET RPAREN *)
 end	 (*  RESERVED_END *)
 else	 (*  RESERVED_ELSE *)
 writeln ( c [ r + 1 ] ) ;	 (*  IDENTIFIER LPAREN IDENTIFIER L_SQUARE_BRACKET IDENTIFIER PLUS B10_NUMBER R_SQUARE_BRACKET RPAREN SEMI_COLON *)
	 (*  *)
 q := q - 1 ;	 (*  IDENTIFIER ASSIGNMENT IDENTIFIER MINUS B10_NUMBER SEMI_COLON *)
 end ;	 (*  RESERVED_END SEMI_COLON *)
	 (*  *)
 t := t - 1 ;	 (*  IDENTIFIER ASSIGNMENT IDENTIFIER MINUS B10_NUMBER SEMI_COLON *)
 end ;	 (*  RESERVED_END SEMI_COLON *)
